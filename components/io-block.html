<link rel="import" href="../bower_components/polymer/polymer.html">
<link rel="import" href="../bower_components/core-toolbar/core-toolbar.html">
<link rel="import" href="../bower_components/core-icon-button/core-icon-button.html">
<link rel="import" href="../bower_components/core-header-panel/core-header-panel.html">
<!-- <link rel="import" href="../bower_components/paper-checkbox/paper-checkbox.html"> -->

<polymer-element name="io-block" draggable=false attributes="icount ocount computor">
    <template>
        <style>
            :host {
                display: block;
                position: absolute;
                background-color: white;
                /*z-index: 2;*/
            }

            core-header-panel {
                width: 150px;
                min-height: 150px;
            }

            .inputs, .outputs {
                width: 50%
            }

            .input, .output {
                margin-top: 15px;
                position: relative;
            } 

            .input label {
                margin-left: 5px;
            }

            .output label {
                margin-right: 5px;
            }

            /* Checkboxes */

            /* :before sert à créer la case à cocher */
            [type="checkbox"]:not(:checked) + label:before,
            [type="checkbox"]:checked + label:before {
              content: '';
              position: absolute;
              /*top: 2px;*/
              width: 17px; height: 17px; /* dim. de la case */
              border: 1px solid #aaa;
              background: #f8f8f8;
              /*box-shadow: inset 0 1px 3px rgba(0,0,0,.3)*/ /* légère ombre interne */
            }

            .input [type="checkbox"]:not(:checked) + label:before,
            .input [type="checkbox"]:checked + label:before {
                border-top-right-radius: 1px;
                border-bottom-right-radius: 1px;
                border-left: none;
                left:-1px;
            }

            .output [type="checkbox"]:not(:checked) + label:before,
            .output [type="checkbox"]:checked + label:before {
                border-top-left-radius: 1px;
                border-bottom-left-radius: 1px;
                border-right: none;
                right:-1px;
            }

            /* :after Aspect général de la coche */
            [type="checkbox"]:not(:checked) + label:after,
            [type="checkbox"]:checked + label:after {
              /*content: '✔';*/
              content: '■';
              position: absolute;
              top: -1px;
              font-size: 43px;
              color: grey;
              line-height: 19px;
              /*transition: all .2s;*/ /* on prévoit une animation */
            }

            .input [type="checkbox"]:not(:checked) + label:after,
            .input [type="checkbox"]:checked + label:after {
              left: -5px;
            }

            .output [type="checkbox"]:not(:checked) + label:after,
            .output [type="checkbox"]:checked + label:after {
              right: -4px;
            }

            /* Aspect si "pas cochée" */
            [type="checkbox"]:not(:checked) + label:after {
              opacity: 0; /* coche invisible */
              /*transform: scale(0);*/ /* mise à l'échelle à 0 */
            }
            /* Aspect si "cochée" */
            [type="checkbox"]:checked + label:after {
              opacity: 1; /* coche opaque */
              /*transform: scale(1);*/ /* mise à l'échelle 1:1 */
            }

            /* aspect désactivée */
            [type="checkbox"]:disabled:not(:checked) + label:before,
            [type="checkbox"]:disabled:checked + label:before {
              /*box-shadow: none;*/
              border-color: #bbb;
              /*background-color: #ddd;*/
            }
            /* styles de la coche (si cochée/désactivée) */
            [type="checkbox"]:disabled:checked + label:after {
              color: #999;
            }
            /* on style aussi le label quand désactivé */
            [type="checkbox"]:disabled + label {
              color: #aaa;
            }
             
            /* aspect au focus de l'élément */
            /*[type="checkbox"]:checked:focus + label:before,
            [type="checkbox"]:not(:checked):focus + label:before {
              border: 1px dotted blue;
            }*/
        </style>

        <core-header-panel id="container" mode="seamed">
            <core-toolbar>
                <span flex>Block</span>
                <core-icon-button icon="menu" on-tap="{{moreAction}}"></core-icon-button>
            </core-toolbar>

            <div horizontal layout center>
                <!-- INPUTS -->
                <div vertical layout class="inputs">
                    <template repeat="{{input, index in inputs}}">
                         <div id="i{{index}}" class="input" layout horizontal>
                            <!-- <paper-checkbox on-change="{{onToggleInput}}" checked?="{{input.wire}}"></paper-checkbox> -->
                            <input id="ci{{index}}" type="checkbox" on-click="{{onToggleInput}}" checked?="{{inputChecked(index, input.wire)}}"></input>
                            <label for="ci{{index}}">In {{index}}</label>
                        </div>
                    </template>
                </div>

                <!-- OUTPUTS -->
                <div vertical layout class="outputs">
                    <template repeat="{{output, index in outputs}}">
                         <div id="o{{index}}" class="output" layout horizontal reverse>
                            <!-- <paper-checkbox on-change="{{onToggleOutput}}" checked?="{{output.wire}}"></paper-checkbox> -->
                            <input id="co{{index}}" type="checkbox" on-click="{{onToggleOutput}}" checked?="{{outputChecked(index, output.wire)}}"></input>
                            <label for="co{{index}}">Out {{index}}</label>
                        </div>
                    </template>
                </div>
            </div>
            <span>O0 = {{outputs[0].value}}</span>
        </core-header-panel>

    </template>


    <script>
    Polymer({

        icount: 2,

        ocount: 1,

        observe: {
            'computor': 'compute',
            'inputs[0].value': 'compute',
            'inputs[1].value': 'compute',
        },

        // computed: {
        //     outputs[0].value = 'inputs | computeOutput'
        // }

        created: function () {
            this.position = {x: 0, y: 0};
        },

        ready: function () {
            var i = 0,
                inputs = [],
                outputs = [];

            while (i < this.icount) {
                inputs.push({
                    wire: undefined,
                    value: undefined
                });
                i++;
            }

            i = 0;

            while (i < this.ocount) {
                outputs.push({
                    wire: undefined,
                    value: undefined
                });
                i++;
            }

            this.inputs = inputs;
            this.outputs = outputs;

        },

        setPosition: function (x, y) {
            var style = this.style;

            //if (x) {
                style.left = x +'px';
                this.position.x = x;
            //}

            //if (y) {
                style.top = y + 'px';
                this.position.y = y;
            //}
        },

        // onTest: function (event, detail, sender) {
        //     sender;
        // },

        inputChecked: function (index, wire) {
            var checked = false, element;
            if (typeof index === 'number') {
                checked =  wire !== undefined;
                element = this.$.container.querySelector('#i' + index + '> input');
                if (element) { element.checked = checked };
            } 
            return checked;
        },

        outputChecked: function (index, wire) {
            var checked = false, element;
            if (typeof index === 'number') {
                checked =  wire !== undefined;
                element = this.$.container.querySelector('#o' + index + '> input');
                if (element) { element.checked = checked };
            }
            return checked;
        },

        onToggleInput: function (event, detail, sender) {
            var index = IO.getIndex(sender.parentElement.id),
                wire;

            // Remove wire if already plugged/checked
            if (!sender.checked && (wire = this.inputs[index].wire)) {
                this.unsetInput(index, true);
                wire.unsetInput(true);
                wire.remove();
                //Manager.endAddWire() // Just in case.
            // Handle new wire if not plugged/checked.
            } else {
                wire = Manager.currentWire;
                // 1) First plug: start add wire.
                if (!wire) {
                    wire = Manager.beginAddWire();
                    wire.setOutput(this, sender.parentElement.id, true);
                // 2) Second plug: stop add wire. Only plug wire output if not already plug (avoid wire between 2 outputs).
                } else if (!wire.isOutputPlugged()) {
                    Manager.endAddWire();
                    wire.setOutput(this, sender.parentElement.id, true);
                } else {
                    event.stopImmediatePropagation();
                    //event.stopPropagation();
                }
            }

            //event.preventDefault();
            //event.stopImmediatePropagation();
            //event.stopPropagation();
        },

        onToggleOutput: function (event, detail, sender) {
            var index = IO.getIndex(sender.parentElement.id),
                wire;

            //Remove wire if already plugged/checked
            if (!sender.checked && (wire = this.outputs[index].wire)) {
                this.unsetOutput(index, true);
                wire.unsetOutput(true);
                wire.remove();
                //Manager.endAddWire() // Just in case.
            // Handle new wire if not plugged/checked.
            } else {
                wire = Manager.currentWire;
                // 1) First plug: start add wire.
                if (!wire) {
                    wire = Manager.beginAddWire();
                    wire.setInput(this, sender.parentElement.id, true);
                // 2) Second plug: stop add wire. Only plug wire input if not already plugged (avoid wire between 2 inputs).
                } else if (!wire.isInputPlugged()) {
                    Manager.endAddWire();
                    wire.setInput(this, sender.parentElement.id, true);
                } else {
                    event.preventDefault();
                    //event.stopImmediatePropagation();
                }
            }

            //event.preventDefault();
            //event.stopImmediatePropagation();
            //event.stopPropagation();
        },

        setInput: function (wire, inputRef, shouldPlugWire) {
            var index = IO.getIndex(inputRef);
            this.inputs[index].wire = wire;
            if (shouldPlugWire) {
                wire.setOutput(this, 'i' + index, false);
            }
        },

        unsetInput: function (inputRef, shouldUnplugWire) {
            var input = this.inputs[IO.getIndex(inputRef)];
            if (shouldUnplugWire) {
                input.wire && input.wire.unsetOutput(false);
            }
            input.wire = undefined;
            input.value = undefined;
        },

        setOutput: function (wire, outputRef, shouldPlugWire) {
            var index = IO.getIndex(outputRef);
            this.outputs[index].wire = wire;
            if (shouldPlugWire) {
                wire.setInput(this, 'o' + index, false);
            }
        },

        unsetOutput: function (outputRef, shouldUnplugWire) {
            var output = this.outputs[IO.getIndex(outputRef)];
            if (shouldUnplugWire) {
                output.wire && output.wire.unsetInput(false);
            }
            output.wire = undefined;
        },

        compute: function () {
            var outputValues;
            if (this.computor) {
                outputValues = this.computor(this.inputs.map(function(i) {
                    return i.value;
                }));

                this.outputs.forEach(function(o, index) {
                    o.value = outputValues[index];
                });
            }
        }
    });
    </script>

</polymer-element>